<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>PacFlag Fullscreen Mobile</title>
<style>
  body,html {
    margin: 0; padding: 0; overflow: hidden; background: black; 
    -webkit-touch-callout: none; /* Disable iOS callout */
    -webkit-user-select: none; /* Disable selection */
    -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
  }
  #hud {
    position: fixed;
    top: 10px; left: 10px;
    color: white;
    font-family: monospace;
    font-size: 20px;
    user-select: none;
    z-index: 10;
  }
  canvas {
    display: block;
    margin: auto;
    background: #111;
    touch-action: none; /* disable default gestures */
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">
  <div id="score"></div>
  <div id="status">Status: Playing</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let TILE = 32;
let ROWS = 20;
let COLS = 20;

function resizeCanvas() {
  const minDim = Math.min(window.innerWidth, window.innerHeight);
  TILE = Math.floor(minDim / ROWS);
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;
}
window.addEventListener('resize', resizeCanvas);

// Map data codes:
// 0 = pellet
// 1 = wall
// 2 = empty/visited
// 3 = power pellet

let map = [];
function generateMap() {
  map = [];
  for (let r=0;r<ROWS;r++){
    map[r] = [];
    for (let c=0;c<COLS;c++){
      if (r===0 || c===0 || r===ROWS-1 || c===COLS-1) map[r][c]=1; // wall
      else map[r][c]=0; // pellet
    }
  }
  // random walls
  for (let r=2;r<ROWS-2;r++){
    for (let c=2;c<COLS-2;c++){
      if (Math.random() < 0.2) map[r][c]=1;
    }
  }
  // tunnels
  map[Math.floor(ROWS/2)][0] = 2;
  map[Math.floor(ROWS/2)][COLS-1] = 2;
  // power pellets in corners
  map[1][1] = 3;
  map[1][COLS-2] = 3;
  map[ROWS-2][1] = 3;
  map[ROWS-2][COLS-2] = 3;
}
generateMap();

// Assets
const ASSETS = {
  pacman: 'pacman.png',
  ghosts: ['ghost1.png','ghost2.png','ghost3.png','ghost4.png']
};
let images = { ghosts: [] };
let loaded = 0;
let totalToLoad = 1 + ASSETS.ghosts.length;
function loadImages(cb){
  images.pacman = new Image();
  images.pacman.src = ASSETS.pacman;
  images.pacman.onload = done; images.pacman.onerror = done;
  ASSETS.ghosts.forEach((src,i)=>{
    const img = new Image();
    img.src = src;
    img.onload = done; img.onerror = done;
    images.ghosts[i] = img;
  });
  function done(){ loaded++; if (loaded===totalToLoad) cb(); }
}

// Entities
const player = { r:Math.floor(ROWS/2), c:Math.floor(COLS/2), dir:{r:0,c:0}, timer:0, powered:false, powerTime:0 };
let ghosts = [];
function resetGhosts(){
  ghosts = [
    {r:1, c:1, dir:{r:0,c:1}, imgIndex:0, timer:0},
    {r:1, c:COLS-2, dir:{r:0,c:-1}, imgIndex:1, timer:0},
    {r:ROWS-2, c:1, dir:{r:0,c:1}, imgIndex:2, timer:0},
    {r:ROWS-2, c:COLS-2, dir:{r:0,c:-1}, imgIndex:3, timer:0},
  ];
}
resetGhosts();

// Scores
let score = 0;
let highScore = parseInt(localStorage.getItem('pacFlagHighScore') || '0');
const scoreEl = document.getElementById('score');
const statusEl = document.getElementById('status');
function updateScoreDisplay(){
  scoreEl.textContent = `Score: ${score} | High Score: ${highScore}`;
}
updateScoreDisplay();

// Controls

// Desktop keyboard:
window.addEventListener('keydown', e=>{
  if (e.key === 'ArrowUp') player.dir = {r:-1,c:0};
  if (e.key === 'ArrowDown') player.dir = {r:1,c:0};
  if (e.key === 'ArrowLeft') player.dir = {r:0,c:-1};
  if (e.key === 'ArrowRight') player.dir = {r:0,c:1};
});

// Mobile swipe detection:
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
const SWIPE_THRESHOLD = 30; // minimal swipe distance in px

canvas.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
});
canvas.addEventListener('touchend', e => {
  const t = e.changedTouches[0];
  touchEndX = t.clientX;
  touchEndY = t.clientY;
  handleSwipe();
});

function handleSwipe(){
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return; // ignore small movements
  if (Math.abs(dx) > Math.abs(dy)){
    // horizontal swipe
    if (dx > 0) player.dir = {r:0, c:1}; // right
    else player.dir = {r:0, c:-1}; // left
  } else {
    // vertical swipe
    if (dy > 0) player.dir = {r:1, c:0}; // down
    else player.dir = {r:-1, c:0}; // up
  }
}

// Helpers
function canWalk(r,c){
  if (r<0||c<0||r>=ROWS||c>=COLS) return false;
  return map[r][c] !== 1;
}
function wrapPosition(entity){
  if (entity.c < 0) entity.c = COLS - 1;
  if (entity.c >= COLS) entity.c = 0;
  if (entity.r < 0) entity.r = ROWS - 1;
  if (entity.r >= ROWS) entity.r = 0;
}
function resetGhost(g){
  g.r = Math.random()<0.5 ? 1 : ROWS-2;
  g.c = Math.random()<0.5 ? 1 : COLS-2;
}
function pelletsRemaining(){
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      if (map[r][c]===0 || map[r][c]===3) return true;
    }
  }
  return false;
}

// Update functions
function updatePlayer(){
  player.timer++;
  if (player.timer < 10) return; // slower movement
  player.timer = 0;
  let nr = player.r + player.dir.r;
  let nc = player.c + player.dir.c;
  if (nr<0||nc<0||nr>=ROWS||nc>=COLS){
    player.r = nr; player.c = nc;
    wrapPosition(player);
    return;
  }
  if (canWalk(nr,nc)){
    player.r = nr; player.c = nc;
    if (map[nr][nc] === 0){ // pellet
      map[nr][nc] = 2;
      score += 10;
      updateScoreDisplay();
    }
    if (map[nr][nc] === 3){ // power pellet
      map[nr][nc] = 2;
      score += 50;
      player.powered = true;
      player.powerTime = 450; // ~15 seconds at 60fps-ish
      updateScoreDisplay();
    }
  }
}
function updateGhosts(){
  ghosts.forEach(g=>{
    g.timer++;
    if (g.timer < 10) return;
    g.timer = 0;

    function opposite(dir){
      return {r:-dir.r, c:-dir.c};
    }

    const dirs = [
      {r:1,c:0},
      {r:-1,c:0},
      {r:0,c:1},
      {r:0,c:-1}
    ];

    let validDirs = dirs.filter(d => canWalk(g.r + d.r, g.c + d.c));
    validDirs = validDirs.filter(d => !(d.r === -g.dir.r && d.c === -g.dir.c));

    let nextDir = g.dir;
    if (!canWalk(g.r + g.dir.r, g.c + g.dir.c) || Math.random() < 0.3 || validDirs.length === 0) {
      if (validDirs.length > 0) {
        nextDir = validDirs[Math.floor(Math.random() * validDirs.length)];
      } else {
        nextDir = opposite(g.dir);
      }
    }

    g.dir = nextDir;

    let nr = g.r + g.dir.r;
    let nc = g.c + g.dir.c;

    if (nr < 0) nr = ROWS - 1;
    else if (nr >= ROWS) nr = 0;
    if (nc < 0) nc = COLS - 1;
    else if (nc >= COLS) nc = 0;

    if (canWalk(nr, nc)) {
      g.r = nr;
      g.c = nc;
    } else {
      g.dir = {r:0,c:0};
    }
  });

  if (player.powered){
    player.powerTime--;
    if (player.powerTime <= 0) player.powered = false;
  }
}
function checkCollisions(){
  for (const g of ghosts){
    if (g.r===player.r && g.c===player.c){
      if (player.powered){
        score += 200;
        resetGhost(g);
        updateScoreDisplay();
      } else {
        statusEl.textContent = 'Status: Caught! Game Over';
        running=false;
        if (score > highScore){
          highScore = score;
          localStorage.setItem('pacFlagHighScore', highScore);
        }
        updateScoreDisplay();
      }
    }
  }
}

// Draw
function draw(){
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const x=c*TILE, y=r*TILE;
      if (map[r][c]===1){
        ctx.fillStyle = '#223';
        ctx.fillRect(x,y,TILE,TILE);
      } else if (map[r][c]===0){
        ctx.fillStyle='#fff';
        ctx.beginPath();
        ctx.arc(x+TILE/2, y+TILE/2, 3, 0, Math.PI*2);
        ctx.fill();
      } else if (map[r][c]===3){ // power pellet
        ctx.fillStyle='#ff0';
        ctx.beginPath();
        ctx.arc(x+TILE/2, y+TILE/2, 6, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  ghosts.forEach(g=>{
    const img=images.ghosts[g.imgIndex];
    const x=g.c*TILE, y=g.r*TILE;
    if (img && img.complete && img.naturalWidth){
      const scale=Math.min(TILE*0.9/img.width, TILE*0.9/img.height);
      ctx.drawImage(img, x+(TILE-img.width*scale)/2, y+(TILE-img.height*scale)/2, img.width*scale, img.height*scale);
    }
  });
  const pimg = images.pacman;
  const px = player.c*TILE, py = player.r*TILE;
  const sizeBoost = player.powered ? 1.3 : 1;
  if (pimg && pimg.complete && pimg.naturalWidth){
    const scale=Math.min((TILE-4)*sizeBoost/pimg.width,(TILE-4)*sizeBoost/pimg.height);
    ctx.drawImage(pimg, px+(TILE-pimg.width*scale)/2, py+(TILE-pimg.height*scale)/2, pimg.width*scale, pimg.height*scale);
  } else {
    ctx.fillStyle= player.powered ? '#0f0' : '#0ff';
    ctx.beginPath();
    ctx.arc(px+TILE/2, py+TILE/2, (TILE-6)/2 * sizeBoost, 0, Math.PI*2);
    ctx.fill();
  }
}

// Game loop & logic
let running=true;
function loop(){
  if (!running) return;
  updatePlayer();
  updateGhosts();
  checkCollisions();
  draw();

  if (!pelletsRemaining()) {
    score += 500; // level clear bonus
    updateScoreDisplay();
    generateMap();
    player.r = Math.floor(ROWS/2);
    player.c = Math.floor(COLS/2);
    player.dir = {r:0,c:0};
    player.powered = false;
    resetGhosts();
    statusEl.textContent = 'Status: New Level!';
  }

  requestAnimationFrame(loop);
}

resizeCanvas();
loadImages(()=>{
  loop();
});
</script>
</body>
</html>


