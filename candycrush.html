import React, { useEffect, useRef, useState } from "react";

const BACKGROUND_URL = "https://images.unsplash.com/photo-1505250469679-203ad9ced0cb?w=1600&q=80&auto=format&fit=crop";
const CANDIES = ["üç¨", "üç≠", "üç´", "üç™", "üç©", "üçí", "üçá", "üçì"];
const START_HEARTS = 5;
const TIMER_SECONDS = 7.0;

// determine max grid size based on full screen width/height
function computeGridSize(width, height) {
  const shortSide = Math.min(width, height);
  if (shortSide < 420) return 7;
  if (shortSide < 600) return 8;
  if (shortSide < 900) return 9;
  if (shortSide < 1200) return 10;
  if (shortSide < 1600) return 11;
  return 12;
}

function emptyTile() {
  return { kind: null, frozen: false };
}

export default function CandyLandMatch3() {
  const [cols, setCols] = useState(8);
  const [rows, setRows] = useState(8);
  const [grid, setGrid] = useState([]);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [selected, setSelected] = useState(null);
  const [hearts, setHearts] = useState(START_HEARTS);
  const [animating, setAnimating] = useState(false);
  const [matchedMap, setMatchedMap] = useState(new Map());
  const [timeLeft, setTimeLeft] = useState(TIMER_SECONDS);
  const [gameOver, setGameOver] = useState(false);

  const timerRef = useRef(null);
  const firstMoveRef = useRef(false);

  // handle resizing properly (no half tiles)
  useEffect(() => {
    function onResize() {
      const size = computeGridSize(window.innerWidth, window.innerHeight);
      setCols(size);
      setRows(size);
    }
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  // init game
  useEffect(() => {
    const saved = parseInt(localStorage.getItem("cl_highscore") || "0", 10);
    setHighScore(isNaN(saved) ? 0 : saved);
    initBoard(rows, cols);
  }, [rows, cols]);

  // high score tracking
  useEffect(() => {
    if (score > highScore) {
      setHighScore(score);
      localStorage.setItem("cl_highscore", String(score));
    }
  }, [score, highScore]);

  function stopTimer() {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  }

  function startTimer() {
    stopTimer();
    timerRef.current = setInterval(() => {
      setTimeLeft((t) => {
        const next = t - 0.1;
        if (next <= 0) {
          handleTimerExpiry();
          return TIMER_SECONDS;
        }
        return next;
      });
    }, 100);
  }

  function handleTimerExpiry() {
    setHearts((h) => {
      const nh = Math.max(0, h - 1);
      if (nh <= 0) setGameOver(true);
      return nh;
    });
    setSelected(null);
  }

  function initBoard(r, c) {
    const size = r * c;
    const b = Array(size)
      .fill(0)
      .map(() => ({ kind: randKind(), frozen: false }));
    for (let i = 0; i < size; i++) {
      let tries = 0;
      while (hasImmediateMatchAt(b, i, r, c) && tries < 12) {
        b[i].kind = randKind();
        tries++;
      }
    }
    const initialFrozen = Math.max(1, Math.floor(size * 0.03));
    for (let k = 0; k < initialFrozen; k++) {
      const idx = Math.floor(Math.random() * size);
      b[idx].frozen = true;
    }
    setGrid(b);
    setScore(0);
    setHearts(START_HEARTS);
    setSelected(null);
    setMatchedMap(new Map());
    setTimeLeft(TIMER_SECONDS);
    stopTimer();
    firstMoveRef.current = false;
  }

  function randKind() {
    return Math.floor(Math.random() * CANDIES.length);
  }

  function hasImmediateMatchAt(b, idx, r, c) {
    const val = b[idx].kind;
    if (val === null) return false;
    const row = Math.floor(idx / c);
    const col = idx % c;
    if (col >= 2 && b[row * c + col - 1].kind === val && b[row * c + col - 2].kind === val) return true;
    if (row >= 2 && b[(row - 1) * c + col].kind === val && b[(row - 2) * c + col].kind === val) return true;
    return false;
  }

  function indexToRC(i) {
    return [Math.floor(i / cols), i % cols];
  }
  function rcToIndex(r, c) {
    return r * cols + c;
  }

  function areNeighbors(a, b) {
    if (a == null || b == null) return false;
    const [ra, ca] = indexToRC(a);
    const [rb, cb] = indexToRC(b);
    return Math.abs(ra - rb) + Math.abs(ca - cb) === 1;
  }

  function canSwap(a, b) {
    if (!areNeighbors(a, b)) return false;
    const ta = grid[a];
    const tb = grid[b];
    if (!ta || !tb) return false;
    if (ta.frozen || tb.frozen) return false;
    return true;
  }

  function onCellTap(i) {
    if (animating || hearts <= 0 || gameOver) return;
    setTimeLeft(TIMER_SECONDS);

    if (!firstMoveRef.current) {
      startTimer();
      firstMoveRef.current = true;
    }

    if (selected === null) {
      if (grid[i].frozen) return;
      setSelected(i);
      return;
    }
    if (selected === i) {
      setSelected(null);
      return;
    }
    if (canSwap(selected, i)) {
      doSwap(selected, i);
      setSelected(null);
    } else {
      setHearts((h) => {
        const nh = Math.max(0, h - 1);
        if (nh <= 0) setGameOver(true);
        return nh;
      });
      setSelected(null);
    }
  }

  function doSwap(a, b) {
    if (animating) return;
    const copy = grid.slice().map((t) => ({ ...t }));
    [copy[a], copy[b]] = [copy[b], copy[a]];
    setGrid(copy);
    setAnimating(true);
    setTimeout(() => {
      resolveCascades(copy).then((didMatch) => {
        if (!didMatch) {
          const revert = grid.slice().map((t) => ({ ...t }));
          setGrid(revert);
          setHearts((h) => {
            const nh = Math.max(0, h - 1);
            if (nh <= 0) setGameOver(true);
            return nh;
          });
        }
        setAnimating(false);
      });
    }, 180);
  }

  async function resolveCascades(startGrid) {
    let anyMatch = false;
    const gridCopy = startGrid.slice().map((t) => ({ ...t }));
    while (true) {
      const matches = findMatches(gridCopy);
      if (!matches.size) break;
      anyMatch = true;
      const matchIndices = Array.from(matches);
      const shatterSet = new Set();
      matchIndices.forEach((idx) => {
        if (gridCopy[idx].frozen) shatterSet.add(idx);
      });
      const newMatched = new Map();
      matchIndices.forEach((i) =>
        newMatched.set(i, { type: gridCopy[i].frozen ? "shatter" : "pop", ts: Date.now() })
      );
      setMatchedMap(newMatched);
      setScore((s) => s + matchIndices.length * 10);
      if (shatterSet.size) {
        setHearts((h) => Math.min(START_HEARTS, h + shatterSet.size));
      }
      await new Promise((res) => setTimeout(res, 480));
      matchIndices.forEach((i) => {
        gridCopy[i] = emptyTile();
      });
      for (let c = 0; c < cols; c++) {
        let write = rows - 1;
        for (let r = rows - 1; r >= 0; r--) {
          const idx = rcToIndex(r, c);
          if (gridCopy[idx].kind !== null) {
            if (write !== r) {
              gridCopy[rcToIndex(write, c)] = gridCopy[idx];
              gridCopy[idx] = emptyTile();
            }
            write--;
          }
        }
        for (let r = write; r >= 0; r--) {
          gridCopy[rcToIndex(r, c)] = { kind: randKind(), frozen: spawnFrozenChance(score) > Math.random() };
        }
      }
      setGrid(gridCopy.map((t) => ({ ...t })));
      await new Promise((res) => setTimeout(res, 160));
    }
    setMatchedMap(new Map());
    setTimeLeft(TIMER_SECONDS);
    return anyMatch;
  }

  function findMatches(bd) {
    const matches = new Set();
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols - 2; c++) {
        const idx = rcToIndex(r, c);
        const k = bd[idx].kind;
        if (k == null) continue;
        if (bd[idx + 1].kind === k && bd[idx + 2].kind === k) {
          let cc = c;
          while (cc < cols && bd[rcToIndex(r, cc)].kind === k) {
            matches.add(rcToIndex(r, cc));
            cc++;
          }
        }
      }
    }
    for (let c = 0; c < cols; c++) {
      for (let r = 0; r < rows - 2; r++) {
        const idx = rcToIndex(r, c);
        const k = bd[idx].kind;
        if (k == null) continue;
        if (bd[idx + cols].kind === k && bd[idx + 2 * cols].kind === k) {
          let rr = r;
          while (rr < rows && bd[rcToIndex(rr, c)].kind === k) {
            matches.add(rcToIndex(rr, c));
            rr++;
          }
        }
      }
    }
    return matches;
  }

  function spawnFrozenChance(currentScore) {
    const base = 0.05;
    const cap = 0.25;
    const extra = Math.min(cap - base, (currentScore / 2000) * (cap - base));
    return base + extra;
  }

  const sizePx = Math.floor(
    Math.min(window.innerWidth, window.innerHeight) * 0.9
  );
  const cellSize = Math.floor(sizePx / Math.max(cols, rows));

  if (gameOver) {
    stopTimer();
    return (
      <div style={{ minHeight: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", background: "#ffe6e6" }}>
        <div style={{ fontSize: 48, fontWeight: "bold", color: "red", fontFamily: "'Comic Sans MS', cursive" }}>Game Over!</div>
        <div style={{ marginTop: 20, fontSize: 20 }}>Your score: {score}</div>
        <div style={{ fontSize: 20 }}>High score: {highScore}</div>
        <button onClick={() => { setGameOver(false); initBoard(rows, cols); }} style={{ marginTop: 30, padding: "10px 20px", fontSize: 18, borderRadius: 8, border: "none", background: "red", color: "white", cursor: "pointer" }}>
          Restart
        </button>
      </div>
    );
  }

  return (
    <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", backgroundImage: `url(${BACKGROUND_URL})`, backgroundSize: "cover", backgroundPosition: "center" }}>
      <div style={{ width: sizePx, height: sizePx, display: "grid", gridTemplateColumns: `repeat(${cols}, ${cellSize}px)`, gridTemplateRows: `repeat(${rows}, ${cellSize}px)`, gap: 4 }}>
        {grid.map((tile, i) => (
          <div key={i} onClick={() => onCellTap(i)} style={{ width: cellSize, height: cellSize, background: "#fff8", display: "flex", alignItems: "center", justifyContent: "center", borderRadius: 6, fontSize: cellSize * 0.5 }}>
            {tile.kind !== null ? CANDIES[tile.kind] : ""}
          </div>
        ))}
      </div>
    </div>
  );
}