<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 Game - Addictive Puzzle</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #faf8ef;
            font-family: Arial, sans-serif;
        }
        #game-container {
            text-align: center;
        }
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #best-score {
            font-size: 18px;
            margin-bottom: 20px;
        }
        canvas {
            background-color: #bbada0;
            border-radius: 10px;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #message {
            font-size: 30px;
            margin-top: 20px;
            color: #776e65;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">Score: 0</div>
        <div id="best-score">Best: 0</div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="message"></div>
    </div>
    <script>
        // 2048 Game Clone in JavaScript and HTML5 Canvas
        // Highly addictive puzzle: Merge tiles to reach 2048 and beyond
        // Mobile-optimized with touch swipe controls
        // Endless play: Continue after 2048, high score tracking

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 4;
        const cellSize = canvas.width / gridSize;
        const colors = {
            0: '#cdc1b4',
            2: '#eee4da',
            4: '#ede0c8',
            8: '#f2b179',
            16: '#f59563',
            32: '#f67c5f',
            64: '#f65e3b',
            128: '#edcf72',
            256: '#edcc61',
            512: '#edc850',
            1024: '#edc53f',
            2048: '#edc22e',
            // For higher tiles
            4096: '#3c3a32',
            8192: '#3c3a32',
            // etc.
        };

        let grid = [];
        let score = 0;
        let bestScore = localStorage.getItem('bestScore2048') || 0;
        let gameOver = false;
        let won = false;

        // Initialize grid
        function initGrid() {
            grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
            addRandomTile();
            addRandomTile();
        }

        // Add random tile (2 or 4)
        function addRandomTile() {
            let emptyCells = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({ row: i, col: j });
                    }
                }
            }
            if (emptyCells.length > 0) {
                let { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[row][col] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        // Draw grid
        function drawGrid() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    ctx.fillStyle = colors[grid[i][j]] || '#3c3a32';
                    ctx.fillRect(j * cellSize + 5, i * cellSize + 5, cellSize - 10, cellSize - 10);
                    if (grid[i][j] !== 0) {
                        ctx.fillStyle = grid[i][j] <= 4 ? '#776e65' : '#f9f6f2';
                        ctx.font = 'bold 40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(grid[i][j], j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
                    }
                }
            }
        }

        // Move tiles in a direction
        function move(direction) {
            let moved = false;
            let newGrid = grid.map(row => row.slice()); // Copy grid

            if (direction === 'up' || direction === 'down') {
                for (let col = 0; col < gridSize; col++) {
                    let column = [];
                    for (let row = 0; row < gridSize; row++) {
                        column.push(newGrid[row][col]);
                    }
                    let newColumn = slide(column, direction === 'down');
                    for (let row = 0; row < gridSize; row++) {
                        if (newGrid[row][col] !== newColumn[row]) moved = true;
                        newGrid[row][col] = newColumn[row];
                    }
                }
            } else { // left or right
                for (let row = 0; row < gridSize; row++) {
                    let newRow = slide(newGrid[row], direction === 'right');
                    if (newGrid[row].join() !== newRow.join()) moved = true;
                    newGrid[row] = newRow;
                }
            }

            if (moved) {
                grid = newGrid;
                addRandomTile();
                checkGameOver();
                checkWin();
            }
        }

        // Slide and merge tiles in one direction (left/up assumed, reverse for right/down)
        function slide(line, reverse = false) {
            if (reverse) line = line.reverse();
            // Remove zeros
            let filtered = line.filter(num => num !== 0);
            // Merge
            let newLine = [];
            for (let i = 0; i < filtered.length; ) {
                if (i < filtered.length - 1 && filtered[i] === filtered[i + 1]) {
                    let merged = filtered[i] * 2;
                    newLine.push(merged);
                    score += merged;
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('bestScore2048', bestScore);
                    }
                    i += 2;
                } else {
                    newLine.push(filtered[i]);
                    i++;
                }
            }
            // Pad with zeros
            while (newLine.length < gridSize) {
                newLine.push(0);
            }
            if (reverse) newLine = newLine.reverse();
            return newLine;
        }

        // Check if game over (no moves left)
        function checkGameOver() {
            let full = true;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === 0) {
                        full = false;
                        continue;
                    }
                    if (i < gridSize - 1 && grid[i][j] === grid[i + 1][j]) return;
                    if (j < gridSize - 1 && grid[i][j] === grid[i][j + 1]) return;
                }
            }
            if (full) {
                gameOver = true;
                document.getElementById('message').textContent = 'Game Over! Tap to Restart';
            }
        }

        // Check if won (reached 2048)
        function checkWin() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === 2048 && !won) {
                        won = true;
                        document.getElementById('message').textContent = 'You Win! Continue or Tap to Restart';
                    }
                }
            }
        }

        // Render loop
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('best-score').textContent = `Best: ${bestScore}`;
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameOver || won) {
                resetGame();
                return;
            }
            switch (e.key) {
                case 'ArrowUp': move('up'); break;
                case 'ArrowDown': move('down'); break;
                case 'ArrowLeft': move('left'); break;
                case 'ArrowRight': move('right'); break;
            }
            render();
        });

        // Handle touch swipes for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameOver || won) {
                resetGame();
                return;
            }
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameOver || won) {
                resetGame();
                return;
            }
            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 50) move('right');
                else if (dx < -50) move('left');
            } else {
                if (dy > 50) move('down');
                else if (dy < -50) move('up');
            }
            render();
        });

        // Reset game
        function resetGame() {
            grid = [];
            score = 0;
            gameOver = false;
            won = false;
            document.getElementById('message').textContent = '';
            initGrid();
            render();
        }

        // Start game
        initGrid();
        render();
    </script>
</body>
</html>
```​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​